# Вычислении площади многоугольника с использованием OpenMP

Данный проект реализует вычисление площади многоугольника, заданного списком координат вершин, 
с использованием параллельного программирования на OpenMP. 

Цель - показать, как можно ускорить вычисления за счет распараллеливания задач.

## Описание Алгоритма
Для вычисления площади многоугольника используется [формула Гаусса](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D1%83%D0%BB%D0%B0_%D0%BF%D0%BB%D0%BE%D1%89%D0%B0%D0%B4%D0%B8_%D0%93%D0%B0%D1%83%D1%81%D1%81%D0%B0):
$\text{Area} = 0.5 * \left| \sum_{i=1}^{n-1} (x_i * y_{i+1} - y_i * x_{i+1}) + (x_n * y_1 - y_n * x_1) \right|$

Где (x_i, y_i) - координаты вершин многоугольника.

OpenMP позволяет параллелить циклы, что эффективно увеличивает скорость выполнения программы на многоядерных процессорах. 
В нашем случае, основная вычислительная нагрузка приходится на цикл, который суммирует произведения координат. 
Этот цикл был распараллелен с использованием OpenMP.

## Почему параллельное вычисление быстрее однопоточного?
Параллельное вычисление позволяет распределить нагрузку между несколькими ядрами процессора. 
В данном случае, цикл, который суммирует произведения координат, разбивается на несколько частей, 
каждая из которых выполняется в отдельном потоке. Это существенно сокращает время выполнения по сравнению с однопоточным вычислением, 
особенно на многоядерных процессорах.

### Потокобезопасность переменной `sum`
Использование директивы `reduction` в OpenMP обеспечивает потокобезопасность для переменной `sum`.

- Директива `reduction(+:sum)` создает копии переменной `sum` для каждого потока.
- Каждый поток выполняет свои вычисления на своей копии `sum`.
- После завершения всех потоков, значения копий складываются в основную переменную `sum`.

Таким образом, обеспечивается корректность и безопасность выполнения параллельных операций на общей переменной.

## Пример запуска программы

### Генерация входных данных

```bash
touch input.txt && g++ input_creator.cpp && ./a.out
```

После этого остается ввести необходимое кол-во строек.

---

### Немного лирики для маководов

Для macos приходится попотеть и кривыми схемами устанавливать llvm ОБЯЗАТЕЛЬНО ИЗ brew, поскольку apple
в какой-то момент решили сломаться. Решение [тут](https://gist.github.com/ijleesw/4f863543a50294e3ba54acf588a4a421), 
ну и множество вопросов на stack overflow.

### Процесс сборки и запуска
После настройки запустить можно следующим образом (предварительно подготовив файл для запуска).

```bash
mkdir -p build && cd build && cmake .. && make
```

Для запуска с замером времени использовать

```bash
time ./openmp_examples
```

## Проведение испытаний

Для создания тестовых данных была написана программа [input_creator.cpp](input_creator.cpp), 
которая быстро генерировала множество точек на окружности в какой-нибудь файл.

Файлы для испытаний будут прикреплены к основному заданию.

Стоит отметить, что в процессе исследования выяснилось, что чтение из файла занимает существенное время работы, 
поэтому было решено изменять время работы подсчета площади многоугольника непосредственно в коде с помощью библиотеки `ctime`.

Также было замечено, что логика работы и скорость на macos с arm и x86_64 существенно отличается. Как правило на arm-ах 
выигрыша от многопоточки от чего-то не выходит, возможное объяснение есть [тут](https://stackoverflow.com/questions/73591488/c-code-compiled-using-homebrews-clang-on-macos-apple-silicon-runs-significant)

Apple сломала совместимость с openmp и использование clang++ компилятора из homebrew значительно медленнее работает не смотря
на то, что я указываю архитектуру и т.д.

В результате такого исследования **было решено тестировать на WSL с процессором `x86_64`**.


# Заключение
Распараллеливание вычислений с использованием OpenMP позволяет значительно ускорить процесс 
за счет эффективного использования ресурсов многоядерных процессоров.